#!/usr/bin/env python3.7
################################################################################
# Третья версия сервера.
# Связываем циклы получения и отправки сообщений.
################################################################################

import asyncio
import logging
import random
import quart

app = quart.Quart(__name__, template_folder="templates", static_folder="static")

log = logging.getLogger(__name__)
logging.basicConfig(level=logging.DEBUG, format="> %(asctime)-15s %(levelname)-8s || %(message)s")

@app.route("/")
async def index():
    return await quart.render_template("index.html")

@app.route("/p/<page>")
async def handle_p(page):
    return await quart.render_template(f"p_{page}.html")

@app.websocket("/ws")
async def handle_ws():
    # Во второй версии сервера код функции был реорганизован, чтобы иметь возможность
    # независимо получать и отправлять сообщения.
    #
    # Однако, мы потеряли функциональность первой версии сервера: отправки "эхом"
    # полученных сообщений. Так получилось из-за потери связи по данным
    # между шагом получения сообщения и шагом отправки сообщения.
    #
    # Чтобы восстановить связь по данным между получающим циклом и отправляющим циклом
    # нам потребуется очередь: будем считать, что это очередь сообщений к отправке.
    # Тогда чтобы отправить в браузер свежеполученное сообщение, достаточно
    # при получении сообщения сразу же положить его в очередь к отправке..

    # Для удобства отслеживания в логах -- введем уникальный идентификатор соединения.
    user = f"{quart.websocket.remote_addr}#{random.randint(1000, 9999)}"

    # Создаем очередь.
    queue = asyncio.Queue()

    # Определяем функцию-цикл отправки сообщений от сервера к браузеру.
    async def sending():
        while True:
            data = await queue.get()
            log.info("Пользователь %s: SEND[%r]", user, data)
            await quart.websocket.send(data)

    # Определяем функцию-цикл получения сообщений от браузера сервером.
    async def receiving():
        while True:
            data = await quart.websocket.receive()
            log.info("Пользователь %s: RECV[%r]", user, data)
            # (!!!) Функциональное изменение.
            # Ставим в очередь на отправку новое сообщение.
            await queue.put(f"Получили '{data}'. Привет от сервера.")

    # Далее без изменений.
    try:
        log.info("Пользователь %s подключился :)", user)
        producer = asyncio.create_task(sending())
        consumer = asyncio.create_task(receiving())
        await asyncio.gather(producer, consumer)
    finally:
        log.info("Пользователь %s отключился :(", user)


# TODO(sandello): Широковещание.
#
# Теперь вам нужно изменить сервер так, чтобы отправленное браузером сообщение
# было получено всеми другими браузерами, подключенными к серверу.
# Для этого необходимо при получении сообщения транслировать его не только
# в очередь сообщений к отправке для текущего браузера, но и во все другие очереди.
# Для этого необходимо помнить все очереди в некоторой структуре данных.
#
# Подсказка 1: обратите внимание на сообщения о подключении и отключении пользователя.
# Подсказка 2: множество всех очередей должно быть глобальной переменной.
#
# Как проверить, что всё получилось?
# (Предполагается, что вы реализовали вычисление уникального имени в браузере.)
#   - открываем браузер 1; в странице вычисляется имя "кошка", отправляется на сервер;
#   - браузер 1 получает от сервера "кошка" в ответ, и в браузере печатается "кошка";
#   - открываем браузер 2; в странице вычисляется имя "собака", отправляется на сервер;
#   - браузер 2 получает от сервера "собака" в ответ, и в браузере печатается "собака";
#   - браузер 1 _также_ получает от сервера "собака", и в браузере 1 выводится "кошка" и "собака".


def main():
    app.config.from_mapping(DEBUG=True, ENV="dev")
    app.run()


if __name__ == "__main__":
    main()
